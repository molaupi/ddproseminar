\documentclass[a4paper,UKenglish]{lipics-v2018}


\usepackage{microtype}

\bibliographystyle{plainurl}

\title{A summary on Delta Debugging and its uses}

\author{Moritz C. Laupichler}{Fakultät für Informatik, Karlsruhe Institute of Technology, Germany}{moritz.laupichler@student.kit.edu}{}{}

\authorrunning{M.\, C. Laupichler}

\Copyright{Moritz C. Laupichler}

\subjclass{\ccsdesc[500]{Software and its engineering~Software testing and debugging}}

\keywords{Delta Debugging}

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{Moritz Laupichler}
\EventNoEds{1}
\EventLongTitle{Proseminar Werkzeuge und Methoden der Software-Analyse, WS18/19}
\EventShortTitle{PS WMSA WS18/19}
\EventAcronym{WMSA}
\EventYear{2018}
\EventDate{October 19, 2018 -- February 1, 2019}
\EventLocation{Karlsruhe, Germany}
\EventLogo{}
\SeriesVolume{1}
\ArticleNo{M6}
\nolinenumbers
\hideLIPIcs


%%%%%%%% Own Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Special symbol font
\usepackage{pifont}
\Pifont{pzd}

% Pseudocode algorithms
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\algrenewcommand{\algorithmiccomment}[1]{\hfill\(//\) #1}

% Colors
\usepackage{xcolor}

%%%%%%%%%%%% Custom Commands %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% DD algorithms abbreviation
\newcommand{\sdd}[0]{\textit{simpledd}}
\newcommand{\dd}[0]{\textit{dd}}
\newcommand{\ddp}{\textit{dd\textsuperscript{+}}}

% Colored text shortcuts
\newcommand{\green}[1]{\textcolor{green}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\gray}[1]{\textcolor{lightgray}{#1}}

% Yesterday and Today
\newcommand{\yd}[0]{\green{Yesterday} }
\newcommand{\td}[0]{\red{Today} }

% The global change set C
\newcommand{\C}[0]{\ensuremath{\mathcal{C}}}

% Possible results of the test function
\newcommand{\cmark}{\text{\ding{51}}}
\newcommand{\xmark}{\text{\ding{55}}}
\newcommand{\qmark}{\textbf{?}}

% Definition subject
\newcommand{\defsub}[1]{\textbf{(#1)} }

% Math mode shortcuts
\newcommand{\set}[1]{\left \{ #1 \right \}}
\newcommand{\nN}[0]{\mathbb{N}}

\begin{document}

\maketitle

\begin{abstract}
	This paper deals with the Delta Debugging method.
\end{abstract}
	
\section{What is Delta Debugging?}

\subsection{Yesterday and today}
\label{ydandtd}

Imagine a software development process where the latest changes to the code cause known tests to fail even though an older version of the code passed these exact tests. As the basis of the Delta Debugging principle we need to define a simple abstraction of this point in the development process: We know a state \yd that passes the tests and a state \td that fails the tests. Furthermore we know all changes that when applied to \yd yield \td. \\
The goal of Delta Debugging is to automate extraction of the exact changes to \yd that cause the failure in \td.  

\subsection{The simple idea}
\label{ddidea}

The basic idea of Delta Debugging is similar to a binary search. Recursively the number of candidates for changes that cause \td to fail is lowered. By disregarding the changes that do not cause failure eventually we end up with the smallest set of changes that when applied to \yd causes the tests to fail. 



\section{Definitions and basework}

The ideas described above need to be abstracted and formalized in order to approach Delta Debugging algorithms.

\subsection{Configurations}

\definition \defsub{Configuration} A change set $c \subseteq \C$ is called \textbf{configuration} where $\C$ is the set of all changes between \yd and \td.

\definition \defsub{Baseline} The empty configuration $\emptyset$ is called a \textbf{baseline}.

\definition \defsub{Test} The function $test: 2^{\C} \to \set{\cmark, \xmark, \qmark}$ determines the test outcome for a configuration. It returns one of three possible results: 
\begin{itemize}
	\item The tests pass: $\cmark$
	\item The tests fail: $\xmark$
	\item No result can be determined: $\qmark$
\end{itemize} 

Let $c \subseteq \C$ be a configuration. $test(c)$ models a suite of regression tests being run on the result of applying all changes in $c$ to \yd. So by definition $test(\emptyset) = \cmark$ ("Yesterday passes") and $test(\C) = \xmark$ ("Today fails") hold.

\definition \defsub{Failure-inducing configuration} A configuration $c$ is called \textbf{failure-inducing} iff 
\[ \forall c' (c \subseteq c' \subseteq \C \rightarrow test(c') \ne \cmark) \] 
holds.

\definition \defsub{Minimal failure-inducing configuration} A failure-inducing configuration $c$ is \textbf{minimal} iff 
\[ \forall c' \subset c: test(c') \ne \xmark \]
holds.\\


These terms abstract the software development situation described in \ref{ydandtd}. The goal of Delta Debugging can now be stated as finding a minimal failure-inducing configuration in $\C$.

\section{Incrementally approaching a plausible DD algorithm}

There is two major difficulties when approaching a Delta Debugging algorithm: interference and inconsistency. A na\"ive Delta Debugging algorithm called \sdd\ will be refined into the \dd\ algorithm and finally the \ddp\ algorithm in this chapter in order to describe and solve both difficulties. 

\subsection{A na\"ive algorithm: \sdd}

The na\"ive algorithm \sdd\ recursively splits \C\ into smaller and smaller parts until one failure-inducing change is found. In each recursion step the current set of changes, $c$, is partitioned in two halves, $c_1$ and $c_2$, and both halves are tested. The half that fails the tests is regarded in the next recursion step. The algorithm knows two cases, "Found in $c_1$" and "Found in $c_2$".
\\
\begin{figure}[h!]
\fbox{\begin{minipage}{\textwidth}
	
\begin{algorithmic}[1]
		\Function{simpledd}{$c: 2^{\C}$}
			\If{$|c| = 1$} \Return $c$ \EndIf
			\State Partition $c$ into two halves $c_1$, $c_2$ so that $c_1 \cap c_2 = \emptyset$
			\If{($test(c_1) = \xmark$)} \Return $simpledd(c_1)$ \Comment("Found in $c_1$") \Else{} \Return $simpledd(c_2)$ \Comment("Found in $c_2$")
			\EndIf
		\EndFunction
\end{algorithmic}
\end{minipage}}
\caption{The na\"ive DD algorithm \sdd}
\end{figure}
\\
It becomes evident that this algorithm is not effective because it is only capable of finding single changes that cause failure on their own. But what if mutiple changes pass the test individually but only their combination induces failure? \\

\definition \defsub{Interference} Two configurations $c_1$ and $c_2$ \textbf{interfere} iff $test(c_1) = \cmark$, $test(c_2) = \cmark$ but $test(c_1 \cup c_2) = \xmark$. \\

\subsection{Dealing with interference: \dd}

\sdd\ is unable to handle the case of both $c_1$ and $c_2$ passing. A new algorithm \dd\ is created which behaves like \sdd\ but incorporates the case "Interference". In this case the algorithm searches for the failure-inducing change in $c_1$ while keeping $c_2$ applied and vice versa. By combining the results of both searches the interfering changes can be extracted.
\\
\begin{figure}[h!]
\fbox{\begin{minipage}{\textwidth}
	
$dd = dd_2(\C, \emptyset)$ where \\

\begin{algorithmic}[1]
	\Function{$dd_2$}{$c,r:2^\C$} $: 2^{\C}$
	\State let $c_1,c_2 \subseteq c \text{ with } c_1 \cup c_2 = c, c_1 \cap c_2 = \emptyset, |c_1| \approx |c_2|$
	\State $d_1 = dd_2(c_1, c_2 \cup r)$ \Comment("Search in $c_1$ while leaving $c_2$ applied")
	\State $d_2 = dd_2(c_2, c_1 \cup r)$ \Comment("Search in $c_2$ while leaving $c_1$ applied")\medskip  
	\State \Return $ \begin{cases}
			c & \text{if } |c|=1, \\
			dd_2(c_1,r) & \text{if } test(c_1 \cup r) = \xmark, \text{\Comment("Found in $c_1$")}\\
			dd_2(c_2,r) & \text{if } test(c_2 \cup r) = \xmark, \text{\Comment("Found in $c_2$")}\\
			d_1 \cup d_2 & \text{otherwise } \text{\Comment("Interference")}
		\end{cases}$
	\EndFunction
\end{algorithmic}
\end{minipage}}
\caption{The \dd\ algorithm capable of dealing with interference.}
\end{figure}
\\

In $dd_2$ the parameter $c$ describes the configuration in which the algorithm is currently searching and the parameter $r$ contains all changes that remain applied during the search in $c$. \\

In \dd\ changes are combined arbitrarily and then tested. It is possible that no test result on the resulting configurations can be determined. 

\definition \defsub{Inconsistent configuration} A configuration $c \subseteq \C$ is called \textbf{inconsistent} iff $test(c) = \qmark$. \\

In the real world of code and regression tests this scenario is most likely caused by a combination of changes resulting in syntactical or semantical errors. An inconsistent configuration may also occur when a change is dependent on another change not included in the configuration or when the program execution fails during testing. 

\dd\ does not deal with inconsistent configurations. It behaves wrong if the configurations that are tested in the "Found" cases are inconsistent.


\subsection{Dealing with inconsistency: \ddp}

The key to solving inconsistency is partitioning $c$ into more than two subsets making the sets of changes smaller. We know that the baseline $\emptyset$ and applying all changes $\C$ are consistent. By applying less changes to \yd or removing less changes from \td (s. case "Preference" below). the chances of the result being consistent is increased. If the algorithm runs into only inconsistent configurations the number of subsets is increased and the chances of at least one configuration being consistent after is increased. This solution requires the final Delta Debugging algorithm to handle any number $n$ of subsets whereas \dd\ only handles two change sets, $c_1$ and $c_2$ at a time.

\definition \defsub{Complement of configuration} Let $c \subseteq \C$ be a configuration. The configuration $\bar{c}$ is called the \textbf{complement} of $c$. It contains all changes that are contained in the current search but not in $c$.\\

The final Delta Debugging algorithm \ddp\ on the subsets $c_1, \dots, c_n$ knows four cases:\\
\begin{description}
	\item["Found in $c_i$"] If testing any $c_i$ fails it contains a failure-inducing subset. Continue search in $c_i$.
	\item["Interference"] If any $c_i$ and $\bar{c_i}$ both pass they form an interference. Continue as in \dd.
	\item["Preference"] If any $c_i$ is unresolved but $\bar{c_i}$ passes then $c_i$ contains a failure-inducing subset. $c_i$ is then preferred. Continue search in $c_i$ while leaving $\bar{c_i}$ applied to promote consistency.
	\item["Try Again"] If none of the above cases apply then continue the search with $2n$ subsets. The chance of consistent configurations is increased.
\end{description}


\begin{figure}[h!]
\fbox{\begin{minipage}{\textwidth}
	
$dd^+(c) = dd_3(c, \emptyset,2)$ where \\

\begin{algorithmic}[1]
	\Function{$dd_3$}{$c,r:2^\C, n: \nN$} $: 2^{\C}$
	\State let $c_1,\dots,c_n \subseteq c \text{ with } \bigcup c_i = c, c_i \text{ pairwise disjoint}, \forall i: |c_i| \approx |c|/n$
	\State let $\bar{c_i} = c \setminus (c_i \cup r), t_i = test(c_i \cup r), \bar{t_i} = test(\bar{c_i} \cup r)$
	\State let $c' = c \cap \bigcap \set{\bar{c_i} \mid \bar{t_i} = \xmark}, r' = r \cup \bigcup \set{c_i \mid t_i = \cmark}, n' = min (\mid c' \mid, 2n)$
	\State let $d_i = dd_3(c_i, \bar{c_i} \cup r, 2), \bar{d_i} = dd_3(\bar{c_i},c_i \cup r, 2)$ 
	\State \Return $ \begin{cases}
			c & \text{if } |c|=1, \text{\Comment("Found")}\\
			dd_3(c_i, r, 2) & \text{if } t_i = \xmark \text{ for some i \Comment("Found in $c_i$")}\\
			d_i \cup \bar{d_i} & \text{if } t_i = \cmark \wedge \bar{t_i} = \cmark \text{ for some i \Comment("Interference")}\\
			d_i & \text{if } t_i = \qmark \wedge \bar{t_i} = \cmark \text{ for some i \Comment("Preference")}\\
			dd_3(c',r',n') & \text{if } n < \mid c \mid \text{\Comment("Try Again")}\\
			c' & \text{otherwise \Comment("Nothing Left")}
		\end{cases}$
	\EndFunction
\end{algorithmic}
\end{minipage}}
\caption{The \ddp\ algorithm capable of dealing with unresolved test cases.}
\end{figure}

\section{Exemplary use cases}

In this chapter three exemplary use cases for Delta Debugging will be shown.

\subsection{Program input analysis}

If a certain input is known to cause a program to fail execution Delta Debugging can be used to analyze which part of the program input is responsible for the failure. The \ddp\ algorithm as defined above can be used without any modifications. It is necessary, though, to define certain abstract concepts in the context of input analysis.\\
\begin{itemize}
  	\item We assume a known minimal input for the program at hand that does not cause failure. In many cases this minimal input would be some sort of "empty" input, be it no data, zero values, etc. This minimal input is regarded as the \yd state.
  	\item The known failing input is regarded as the \td state.
  	\item A change is defined as the smallest possible difference between any two possible inputs, usually a letter, number or other token of data. $\C$ can then be any set of changes that convert the minimal input \yd to the failing input \td.
  	\item The $test$ function returns $\xmark$ if exactly the known error occurs on program execution. It returns $\cmark$ if no error occurs and $\qmark$ in all other cases. 
\end{itemize}

Running \ddp\ with these concrete definitions finds the parts of the input that are responsible for the failure. If the input itself is faulty the error will be revealed directly. If the error lies within the program the algorithm delivers a starting point for manually debugging the error.

Consider as an example the C program \texttt{fail.c} which caused the GNU C Compiler (GCC) in version XY %TODO VERSION!
to crash. The program looks like correct C code that should be able to be compiled. We'd like to use Delta Debugging to find out which part of \texttt{fail.c} is responsible for the crash. For this an empty C program is regarded as the \yd state and \texttt{fail.c} as the \td state. A change is defined as a C language token. $\C$ is comprised of all tokens in \texttt{fail.c}. As depicted in \ref{fig:ddponfail} \ddp\ only takes 21 tests to find out that the C tokens "$+ 1.0$" are a minimal failure-inducing set of changes.
\\
\begin{figure}[h!]
	\fbox{
		\begin{minipage}{\textwidth}
			\begin{centering}
			\begin{tabular}{clc}
				\# & GCC input & test \\
				\hline
				1 & double mult($\dots$) $\{ int \; i, j; \; i = 0; \; for (\dots) \{ \dots\} \dots\}$ & $\xmark$ \\
				2 &\gray{ double mult($\dots$) $\{ int \; i, j; \; i = 0; \; for (\dots) \{ \dots\} \dots\}$} & $\cmark$ \\
				3 & double mult($\dots$) $\{\gray{ int \; i, j; \; i = 0; \; for (\dots) \{ \dots\} \dots}\}$ & $\cmark$ \\
				4 & double mult($\dots$) $\{ int \; i, j; \; i = 0; \; \gray{for (\dots) \{ \dots\} \dots}\}$ & $\cmark$ \\
				5 & double mult($\dots$) $\{ int \; i, j; \; i = 0; \; for (\dots) \{ \dots\}\gray{ \dots}\}$ & $\xmark$ \\
				6 & double mult($\dots$) $\{ int \; i, j; \; i = 0; \; for (\gray{\dots}) \{ \dots\} \gray{\dots}\}$ & $\cmark$ \\

				\vdots & \multicolumn{1}{c}{\vdots} & \vdots \\
				18 & \multicolumn{1}{c}{\dots \quad $z[i] = z[i] * (z[0] + 1.0);$ \quad \dots } & \xmark \\
				19 & \multicolumn{1}{c}{\dots \quad $z[i] = z[i] * (z[0] \gray{+ 1.0});$ \quad \dots } & \cmark \\
				20 & \multicolumn{1}{c}{\dots \quad $z[i] = z[i] * (z[0] \gray{+} 1.0);$ \quad \dots } & \qmark \\
				21 & \multicolumn{1}{c}{\dots \quad $z[i] = z[i] * (z[0] + \gray{1.0});$ \quad \dots } & \qmark \\
			\end{tabular}
			\end{centering}
		\end{minipage}
	}
	\label{fig:ddponfail}
	\caption{How \ddp\ finds the part of \texttt{fail.c} that is responsible for GCC crashing.}
\end{figure}


\subsection{Program runtime analysis}
\subsection{Minimizing random unit test cases}
\subsubsection{The ddmin algorithm}

\section{Reflection and conclusion}
\subsection{Abstractness: strength and weakness}
\subsection{Conclusion}


\end{document}